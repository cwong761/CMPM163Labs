<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Lab 5c: singing in the rain</title>
        <style>
            body { margin: 0; }
            canvas { display: block; }
        </style>
    </head>
    <body>
        <script src="../three.js-master/build/three.js"></script>
        <script>
            // setup the scene
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            camera.position.z = 60;
            
            ambient = new THREE.AmbientLight(0x555555);
            scene.add(ambient);
            directionalLight = new THREE.DirectionalLight(0xffeedd);
            directionalLight.position.set(0,0,1);
            scene.add(directionalLight);
            
            var vertices = [];

            for ( var i = 0; i < 1000; i ++ )
            {
                var x = THREE.MathUtils.randFloatSpread( 500 );
                var y = THREE.MathUtils.randFloatSpread( 500 );
                var z = THREE.MathUtils.randFloatSpread( 100 );
                vertices.push( x, y, z );
            }
            
            var geometry = new THREE.BufferGeometry();
            geometry.setAttribute( 'position', new THREE.Float32BufferAttribute(vertices, 3));
            
            var sprite = new THREE.TextureLoader().load('fog.png');
            var material = new THREE.PointsMaterial( { size: 13.2, sizeAttenuation: true, map: sprite, 
                                                      alphaTest: 0.5, transparent: true } );
            //material.color.setHSL( 1.0, 0.3, 0.7 );

            var points = new THREE.Points(geometry, material);
            scene.add(points);
            
            var windowHalfX = window.innerWidth / 2;
            var windowHalfY = window.innerHeight / 2;
            var mouseX = 0;
            var mouseY = 0;

            function onDocumentMouseMove(event)
            {
                mouseX = event.clientX - windowHalfX;
                mouseY = event.clientY - windowHalfY;
            }

            function onDocumentTouchStart(event)
            {
                if (event.touches.length == 1)
                {
                    event.preventDefault();
                    mouseX = event.touches[0].pageX - windowHalfX;
                    mouseY = event.touches[0].pageY - windowHalfY;
                }
            }

            function onDocumentTouchMove(event)
            {
                if (event.touches.length == 1)
                    {
                        event.preventDefault();
                        mouseX = event.touches[0].pageX - windowHalfX;
                        mouseY = event.touches[0].pageY - windowHalfY;
                    }
            }

            document.addEventListener('mousemove', onDocumentMouseMove, 
            false);
            document.addEventListener('touchstart', onDocumentTouchStart, 
            false);
            document.addEventListener('touchmove', onDocumentTouchMove, 
            false);
            
            
            const rainGeo = new THREE.Geometry();
            for(let i=0;i<10000;i++)
            {
               const rainDrop = new THREE.Vector3(
                Math.random() * 400 -200,
                Math.random() * 500 - 250,
                Math.random() * 400 - 200
              );
              rainGeo.vertices.push(rainDrop);
            }
            
            const rainMaterial = new THREE.PointsMaterial({
              color: 0xaaaaaa,
              size: 0.1,
              transparent: true
            });
            const rain = new THREE.Points(rainGeo,rainMaterial);
            scene.add(rain);
            
            rainDrop.velocity = {};
            rainDrop.velocity = 0;


            function animate()
            {
                rainGeo.vertices.forEach(p => {
                  p.velocity -= 0.1 + Math.random() * 0.1;
                  p.y += p.velocity;
                  if (p.y < -200) {
                    p.y = 200;
                    p.velocity = 0;
                  }
                });
                rainGeo.verticesNeedUpdate = true;
                rain.rotation.y +=0.002;
                
                camera.position.x += (mouseX - camera.position.x) * 0.0005;
                camera.position.y += (-mouseY - camera.position.y) * 0.0005;
                
                var time = Date.now() * 0.00005;
                var h = (360 * (1.0 + time) % 360) / 360;
                //material.color.setHSL(h, 0.5, 0.5);

                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            animate();
        </script>
    </body>
</html>
